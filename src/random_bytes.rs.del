// src/random_bytes.rs
//! Type-safe freshly-generated random bytes.
//!
//! `RandomBytes<N>` guarantees the data was produced by the crate’s secure RNG.
//! It is a newtype over `Fixed<[u8; N]>` so you get all the same zero-cost
//! ergonomics and exposure rules.

#[cfg(feature = "rand")]
use crate::rng::OS_RNG;

use crate::Fixed;

/// Fresh cryptographically-secure random bytes of exactly `N` length.
///
/// Construction is only possible through the RNG — you cannot build one manually.
/// This gives compile-time assurance that the value is truly random.
#[derive(Clone, Copy)]
pub struct RandomBytes<const N: usize>(Fixed<[u8; N]>);

impl<const N: usize> RandomBytes<N> {
    /// Generate fresh cryptographically-secure random bytes.
    #[cfg(feature = "rand")]
    #[inline(always)]
    pub fn new() -> Self {
        let mut bytes = [0u8; N];
        OS_RNG.with(|rng| {
            use rand::TryRngCore;
            rng.borrow_mut()
                .try_fill_bytes(&mut bytes)
                .expect("OsRng failed — this should never happen")
        });
        Self(Fixed::new(bytes))
    }

    /// **Deprecated** — use `new()` instead.
    #[cfg(feature = "rand")]
    #[deprecated(
        since = "0.6.0",
        note = "use `new()` instead — idiomatic and avoids self-named constructor"
    )]
    #[doc(alias = "new")]
    #[inline(always)]
    pub fn random_bytes() -> Self {
        Self::new()
    }

    /// Legacy name — kept only for soft migration.
    #[cfg(feature = "rand")]
    #[deprecated(since = "0.6.0", note = "use `new()` instead — clearer and idiomatic")]
    #[doc(alias = "new")]
    #[inline(always)]
    pub fn random() -> Self {
        Self::new()
    }
}

// Deref so you keep all the nice Fixed methods (len, as_slice, etc.)
impl<const N: usize> core::ops::Deref for RandomBytes<N> {
    type Target = Fixed<[u8; N]>;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

// Optional: Debug redaction
impl<const N: usize> core::fmt::Debug for RandomBytes<N> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("[REDACTED_RANDOM]")
    }
}
